# Advance 聚合SDK对接文档-Android

<font size = "4">**版本号：v3.5.0**


## 1.集成须知

1. Advance 聚合SDK示例Demo	:

2. Advance 聚合SDK工作流程图示
![](advMapHigh.png)
3. 各个广告SDK平台聚合支持情况

 | 平台\广告位| 	开屏 |  激励视频 | 横幅| 插屏 | 信息流 | 全屏视频 | 自定义广告
|:------------- |:---------------|  :---------------|  :---------------|  :---------------|  :---------------|  :---------------|   :---------------|  
| Mercury |✅ |✅ |✅ |✅ |✅ | ❌| ✅
| 广点通  |✅ |✅ |✅ |✅ |✅ |✅ |✅
| 穿山甲|✅ |✅ |✅  |✅|✅|✅  |✅
| 百度 |✅  |✅  |✅ | ✅ | ❌ | ❌ |✅ 
| 快手 |✅ |✅ | ❌ | ❌ | ✅ | ✅|✅


4. SDK渠道平台信息：

	| SDK平台: | 	大小  | 兼容版本号|  SDK标识 ID |
	|:-------------|:---------------|  :---------------|  :---------------| 
| Mercury|0.3M |v3.4.3 | "1" 
|广点通| 1.4M  |  v4.333.1203 | "2"| 
|穿山甲| 1.8M |v3.5.5.0|  "3"
| 百度|0.6M | v5.96|  "4"
|快手|1.1M |v3.3.5.3|  "5"


5. 文档中各位置初始化需要的**聚合广告位id**为Advance后台通过流量管理所创建

6. **策略最佳实践**说明
   
   一、 工具效果类APP：
   
   此类APP基本不存在CPT投放，建议 **使用缓存策略模式**，配置策略缓存时间>7天，缓存下加载策略仅**10ms左右**，非缓存平均**200ms左右**，缓存可以缩短单次广告请求整体耗时进而提升广告展示效果。
  
   
   二、 视频娱乐类APP、小而美APP最佳实践：
   
  此类APP可能会存在较多的CPT投放订单，建议**使用实时策略模式**，可根据运营情况，动态调整为缓存模式，建议缓存时间设置不超过3天。
   
  
7. **隐私政策**相关说明和建议：

	工信部191号文和337号明确了APP违规收集用户信息的认定方法，[点此查看细则](https://blog.csdn.net/t1996ys/article/details/109121933)，为防止媒体接入SDK中产生被判定违规行为，建议严格遵守以下方案：
	- APP自有隐私政策说明中一定要**标明委托AdvanceSDK收集使用个人信息的目的、方式、范围**等。[点此查看AdvanceSDK隐私政策说明](http://www.bayescom.com:81/privacy.html)
	- 在调用SDK加载广告方法之前，需要询问用户是否授权获取设备信息等隐私相关权限。**一定要在用户同意隐私政策之后，再调用SDK加载广告方法，切忌提前或者未同意时请求广告**。


## 2.SDK引入

推荐使用gradle引入，如果gradle引入不成功可以联系我们提供本地aar来引入，引入参考如下：

**注意：** 渠道依赖包默认打包了各平台SDK的aar包，如果本地有引入相同SDK渠道aar请移除本地包，或者使用core渠道包。

APP项目目录下build.gradle配置参考：

```groovy
dependencies {
    def advanceVersion = "3.5.0"
    //必须，MSA Android10以上设备唯一标识 OAID SDK 引入
    implementation 'io.github.flayone:oaid-sdk:1.0.25'
    //必须，Advance聚合SDK 引入。如果gradle引入异常，请参考根目录gradle进行配置，如果依然无法引入，请联系我们使用本地aar引入。
    implementation "io.github.flayone:advance-core:${advanceVersion}"
    //必须，mercury SDK 引入 包含了广告aar以及渠道处理逻辑
    implementation "io.github.flayone:advance-mry:${advanceVersion}_343"
    //穿山甲、广点通、百度SDK 引入，包含了广告aar以及渠道处理逻辑(如果APP本地引入了平台SDK的aar，不希望使用带aar引入的advance渠道库，可以在版本号后面加上 _core 标识，这样就不会产生aar引入冲突了，但是请注意，非advance推荐版本可能会出现广告加载异常，一定要充分测试)
    implementation "io.github.flayone:advance-gdt:${advanceVersion}_4333"
    implementation "io.github.flayone:advance-csj:${advanceVersion}_3550"
    implementation "io.github.flayone:advance-bd:${advanceVersion}_596"
    //快手SDK 引入
    implementation "io.github.flayone:advance-ks:${advanceVersion}_3353_core"
    implementation "io.github.flayone:advance-kslib:${advanceVersion}_3353"
}
```


项目根目录build.gradle配置参考，需要额外添加下方**s01.oss.sonatype**根域名的依赖地址：

```groovy
allprojects {
    repositories {
        maven { url 'http://maven.aliyun.com/nexus/content/groups/public/' }
        //advance相关引用的maven依赖根目录地址
        maven { url 'https://s01.oss.sonatype.org/content/groups/public' }
        google()
    }
}
```


## 3.OAID说明

为了更好地展示广告，Advance 需要集成OAID SDK。

如果APP内部有集成较低版本的OAID SDK，建议替换为最新版。OAID详细说明以及版本变化详见 [移动安全联盟 MSA 官网](https://msa-alliance.cn/col.jsp?id=120)。


## 4.AndroidManifest.xml配置

1.为防止项目构建时抛 `Manifest merger failed`异常，需要在AndroidManifest.xml中加入以下适配代码，兼容SDK引用版本。

```
<!-- 如果引入快手，com.advance.supplier.ks和com.kwad.sdk一定要添加-->
<uses-sdk tools:overrideLibrary="com.bun.miitmdid,com.advance.supplier.ks,com.kwad.sdk" />
```

2.SDK渠道包中已配置好需要的信息，无需再注册广告相关的Activity和Service。如果本地已经引入了相同的配置代码，可能会报**AndroidManifest merge** 错误，可以参考报错的修改建议进行对应内容的**replace**操作。

 
## 5.代码混淆配置

SDK包中已经做了代码混淆配置，不需要额外的混淆配置。

## 6.广告位接入代码示例

详细处理代码可以参考AdvanceDemo工程。

### 初始化SDK

初始化操作一定要在广告请求之前进行，建议在Application的onCreate方法中进行初始化操作。：

```java
public class MyApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        //必要配置：初始化聚合SDK，三个参数依次为context上下文，appId媒体id，isDebug调试模式开关
        AdvanceSDK.initSDK(this,"100171",true);
        //推荐配置：允许Mercury预缓存素材
        MercuryAD.needPreLoadMaterial(true);
    }
}
```

<details  <font color="#0000ff">初始化详细API方法</font> >
<summary> <font color="#0000ff">查看更多可配置信息 </font> </summary>

通过调用 AdvanceSDK类和AdvanceConfig.getInstance()对象中的方法，可以进行一些个性化配置。

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------| 
| AdvanceSDK.setAppNameInCsj(String appName) |设置穿山甲后台中填写的应用名称|可选
| AdvanceConfig.getInstance().setKsAppName(String ksAppName)|设置在快手平台申请应用的应用名称|可选
| AdvanceConfig.getInstance().setNeedPermissionCheck(boolean needPermissionCheck)|穿山甲全局设置项 <br/> true 代表请求穿山甲广告前会进行权限检查和申请，默认false | 可选
|AdvanceConfig.getInstance().setSupportMultiProcess(boolean supportMultiProcess)  |穿山甲全局设置项  <br/> 是否支持多进程，true支持，默认true | 可选
|AdvanceConfig.getInstance().setCsjDirectDownloadNetworkType(int[] csjDirectDownloadNetworkType)  |穿山甲全局设置项 <br/> 设置穿山甲允许直接下载的网络状态集合，状态集合参考 TTAdConstant.NETWORK_STATE_XX | 可选
|MercuryAD.setOAID(Context context, String oaid)|Mercury SDK 全局设置项  <br/> 设置Mercury SDK的OAID值，预留防止msa版本不一致导致获取不到OAID，导致填充低 |可选
|MercuryAD.needPreLoadMaterial(boolean needPreLoadMaterial)  |Mercury SDK 设置是否允许预缓存素材，默认flase不预缓存|可选

</details>
  

---

### 6.1开屏广告(AdvanceSplash)

集成最佳实践：

- 广告时长 **5 秒**为宜；
- 展示区域最好**大于整体画面 75%且高度不得低于400dp**，全屏效果更佳；
- 开屏请求、展示时机：**使用单独的页面展示开屏**，且加载广告时尽量不要进行其他的网络请求或耗时操作，这类操作可以在广告曝光或加载失败回调事件以后再进行。
- Mercury开屏广告常见尺寸有两种比例：1）2:3 比例，多用尺寸为 640*960、1280x1920；2） 9:16 比例，多用尺寸为 720x1280、1080x1920;
- 由于平台实现差异性，**开屏跳转处理逻辑请严格参考demo中代码**，否则可能出现点击跳转异常



加载、展示广告核心方法，详细请参考demo中代码：


```java
//开屏初始化；adContainer为广告容器，skipView不需要自定义可以为null
advanceSplash = new AdvanceSplash(this,  "聚合splash广告位id", adContainer, skipView);
//必须：设置开屏核心回调事件的监听器。
advanceSplash.setAdListener(this);
//必须：请求策略并请求和展示广告，如果targetSDKVersion >= 23，需要申请好权限,如果您的App没有适配到Android6.0（即targetSDKVersion < 23）或者已经提前申请权限，那么只需要在这里直接调用loadAd方法。
advanceSplash.loadStrategy();
```

跳转首页处理参考：

```java
    /**
     * @param id 代表当前被选中的策略id，值为"1" 代表mercury策略 ，值为"2" 代表广点通策略， 值为"3" 代表穿山甲策略
     */
    @Override
    public void onSdkSelected(String id) {
        //给sdkId赋值用来判断被策略选中的是哪个SDK
        sdkId = id;
    }

    @Override
    public void onAdSkip() {
        new Handler(Looper.getMainLooper()).postDelayed(new Runnable() {
            @Override
            public void run() {
                next();
            }
        }, 100);
    }

    @Override
    public void onAdTimeOver() {
        new Handler(Looper.getMainLooper()).postDelayed(new Runnable() {
            @Override
            public void run() {
                next();
            }
        }, 100);
    }
    
  @Override
    protected void onPause() {
        super.onPause();
        // 穿山甲处理逻辑,h5类型的广告，跳转后返回不会回调onAdSkip或者onAdTimeOver，会导致无法跳转首页，需要在这里额外处理跳转逻辑
        canJump = TextUtils.equals(sdkId, "3");
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (canJump) {
            next();
        }
        canJump = true;
    }

    /**
     * 设置一个变量来控制当前开屏页面是否可以跳转，当开屏广告为普链类广告时，点击会打开一个广告落地页，此时开发者还不能打开自己的App主页。当从广告落地页返回以后，
     * 才可以跳转到开发者自己的App主页；当开屏广告是App类广告时只会下载App。
     */
    private void next() {
        if (canJump) {
            goToMainActivity();
        } else {
            canJump = true;
        }
    }

    /**
     * 跳转到主页面
     */
    private void goToMainActivity() {
        Intent intent = new Intent(SplashActivity.this, SplashToMainActivity.class);
        intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
        startActivity(intent);
        this.finish();
    }

```


<details>
  <summary><font color="#0000ff">查看更多可配置信息</font></summary>

#### 相关API说明：

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------|  
|AdvanceSplash(Activity activity, String adspotId, ViewGroup adContainer, TextView skipView) |开屏初始化方法，adspotId 为聚合广告位id同时也是Mercury 渠道的广告位id，adContainer为开屏页的展示根布局，skipView为跳过按钮的自定义view，传null代表不自定义，会使用默认的跳过按钮| 必须
|setAdListener(AdvanceSplashListener listener) | 设置开屏各个事件的回调监听器，具体回调含义参考下方AdvanceSplashListener 说明| 必须
|loadStrategy()| 加载广告策略，根据返回的渠道顺序进行请求并展示广告，注意最好是申请好权限以后再调用此方法。| 必须
|enableStrategyCache(boolean enableCache) | 是否开启策略缓存。注意这里缓存的是SDK的调度策略，而非缓存的广告信息。不设置默认关闭   | 可选，具体参考**1.6 最佳实践说明**
| setSkipText(String skipText) | 自定义跳过按钮的字体，不设置默认显示为："跳过 %d " ，%d为剩余秒数| 可选	
|以下为穿山甲 SDK 渠道特有设置
|setCsjAcceptedSize(int width, int height)|设置穿山甲广告图片偏好尺寸，单位px，不设置默认宽1080px 高1920px | 可选
|setCsjExpressViewAcceptedSize(float expressViewWidth, float expressViewHeight) |模板广告需要设置期望个性化模板广告的大小,单位dp,代码位是否属于个性化模板广告，请在穿山甲平台查看，不设置默认宽360dp，高640dp |  模板广告必须
|以下为Mercury SDK 渠道特有设置
|setLogoImage(Drawable logoImage)| 设置Mercury SDK 开屏底部logo图标 | 可选
|setHolderImage(Drawable holderImage)| 设置Mercury SDK 开屏展示占位图，当广告素材渲染中会展示此处设置的图片，不设置默认无占位 | 可选
|MercuryAD.setLargeADCutType(LargeADCutType largeADCutType) | 素材展示模式设置，不设置默认为LargeADCutType.DEFAULT 保持素材原始比例 |  可选
|MercuryAD.setSplashBackgroundColor(@ColorInt int color) | 设置开屏背景颜色，默认透明。| 可选
|MercuryAD.setSplashForceShowLogo(boolean forceShowLogo)  | 是否强制显示开屏logo，前提是设置了底部logo图标 ，默认关闭| 可选
|MercuryAD.setSplashForceLogoHeight(int forceLogoHeightDP) | 自定义强制显示的开屏logo高度，单位dp，默认-1不限制高度 | 可选
|MercuryAD.setSplashCountDownDuration(int duration) | 设置开屏倒计时时长，最低3s 最高10s| 可选
|MercuryAD.setRichSplashCountDown(boolean countDown) | 设置富媒体开屏是否进行倒计时 ，默认true| 可选
|MercuryAD.setSplashHolderShowMode(SplashHolderMode splashHolderShowMode) | 设置开屏占位图的渲染方式<br/> SplashHolderMode.DEFAULT 默认设置，使用imageView的 setBackground 方法进行图片的填充，不同手机下可能会有一点图片变形 <br/> SplashHolderMode.GlIDE 使用glide方式加载 | 可选
|以下为广点通 SDK 渠道特有设置
|setGdtSkipContainer(View gdtSkipContainer) | 设置广点通的跳过载体，传入一个默认可见view给广点通进行可见检查机制 |可选
|setGdtClickAsSkip(boolean gdtClickAsSkip) | 设置广点通的广告点击后是否以onAdSkip(跳过事件)来回调，适合跳过和倒计时结束处理逻辑不同时设置，处理逻辑相同请忽略。true 点击广点通广告关闭后回调onAdSkip，false 回调 onAdTimeOver；默认为false。| 跳过按钮有特殊处理逻辑时使用，无则忽略
|setGdtCustomSkipHide(boolean gdtCustomSkipHide) | 广点通自定义跳过是否提前隐藏，避免跳过按钮提前展示。| 可选
|setCsjTimeOutQuit(boolean csjTimeOutQuit)  | 穿山甲返回time out回调时，是否退出策略，true 退出false 继续加载下个策略，false。| 可选

</details>

* 开屏事件回调 **AdvanceSplashListener**


| 方法名| 	方法介绍|  
|:------------- |:---------------|  
|onAdLoaded()	|成功获取广告信息回调
|onAdShow()	|广告成功展示回调 
|onAdFailed(AdvanceError advanceError) 	|广告加载失败回调，此时关闭开屏跳转主页
|onAdClicked()|	广告被点击回调
|onAdSkip()|	用户跳过广告回调，此时关闭开屏跳转主页，注意处理不同渠道的跳转条件，详见demo
|onAdTimeOver()|	倒计时结束回调，此时关闭开屏跳转主页，注意处理不同渠道的跳转条件，详见demo
|onSdkSelected(String sdkID) | 当前选中的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID


### 6.2横幅广告(AdvanceBanner)

集成最佳实践：

- 适用场景：一般会在 APP 页面的底部或中部呈现。
- 常见尺寸：640*100 是最常见的 Banner 尺寸。
- 穿山甲横幅在列表中展示存在异常，如果想在列表展示广告建议使用模板信息流方式接入，或者渠道中不配置穿山甲渠道。
- 如果banner放在有触摸交互的view中时，请确保非交互情况下`onInterceptTouchEvent`事件返回为`false`，否则会出现广告无法点击问题。
- 若开启了自动刷新，广告所在页面移除时，务必调用广告`destroy()`方法，移除广告资源


请求广告核心方法，详细请参考demo中代码：


```java
//rl是banner的父布局，用来展示广告
advanceBanner = new AdvanceBanner(this, rl, "聚合banner广告位id");
//推荐：核心事件监听回调
advanceBanner.setAdListener(this);
//必须：请求策略并请求和展示广告
advanceBanner.loadStrategy();
```


<details>
  <summary><font color="#0000ff">查看更多可配置信息</font></summary>

#### 相关API说明：

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------|  
|AdvanceBanner(Activity activity, ViewGroup adContainer, String adspotId) | 广告初始化方法，adContainer是广告的展示父布局，adspotId为聚合广告位id同时也是Mercury 渠道的广告位id | 必须
|setAdListener(AdvanceBannerListener listener) | 设置各个事件的回调监听器，具体回调含义参考下方AdvanceBannerListener 说明| 必须
|loadStrategy()| 加载广告策略，根据返回的渠道顺序进行请求并展示广告。| 必须
|destroy() | 销毁广告，页面销毁的时候要调用此方法 | 必须
|enableStrategyCache(boolean enableCache) | 是否开启策略缓存。注意这里缓存的是SDK的调度策略，而非缓存的广告信息。不设置默认关闭  <br/>后台广告位 |  可选，具体参考**1.6 最佳实践说明**
|setRefreshInterval(int refreshInterval) | 设置刷新间隔（单位秒），不设置默认不刷新| 可选
|setAdListener(AdvanceBannerListener listener) | 设置广告事件的回调监听 | 可选
|以下为穿山甲 SDK 渠道特有设置
|setCsjAcceptedSize(int width, int height)  | 设置穿山甲广告图片偏好尺寸，单位px，不设置默认宽640px，高100px | 可选
|setCsjExpressViewAcceptedSize(int width, int height)  | 模板广告需要设置期望个性化模板广告的大小,单位dp,代码位是否属于个性化模板广告，请在穿山甲平台查看，不设置默认宽640dp，高100dp | **模板广告必须**
</details>

* 事件回调 **AdvanceBannerListener**

| 方法名| 	方法介绍|  
|:------------- |:---------------|  
|onAdLoaded()	|成功获取广告信息回调
|onAdShow()	|广告成功展示回调 
|onAdFailed(AdvanceError advanceError) 	|广告加载失败回调
|onAdClicked()|	广告被点击回调
|onDislike()|	用户关闭广告回调
|onSdkSelected(String sdkID) | 当前选中的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID


 
### 6.3插屏(AdvanceInterstitial)

 
集成最佳实践：

- 适用场景：一般暂停时（多见于视频类 APP 节目暂停）；页面间跳转、切换时（比如游戏类 APP 过关、工具类 APP 页面转换）；APP 退出时；返回上一级时等场景，均可适当植入插屏广告。
- 常见尺寸：插屏广告尺寸通常等于或大于手机屏幕的一半，多设计 600x600、600x500 等规格。
- 一些建议：不要突然展示广告，最好在用户完成应用内操作后自然而然的植入，比如游戏通关后、视频播放结束后；
无论是插屏广告植入场景，还是展示频次，媒体均需要反复测试，以达到最佳变现效果；
- 插屏支持提前加载广告（注意控制时机，不可过早提前），但要注意，一次展示需对应一个广告实例，切忌复用广告实例。



请求广告核心方法，详细请参考demo中代码：


```java
//初始化广告
advanceInterstitial = new AdvanceInterstitial(this, "聚合插屏广告位id");
//推荐：核心事件监听回调
advanceInterstitial.setAdListener(this);
//必须：请求策略并请求广告
advanceInterstitial.loadStrategy();
```

展示广告

```java
//广告加载成功回调
@Override
public void onAdReady() {
    //展示广告
    advanceInterstitial.show();
}
```

<details>
  <summary><font color="#0000ff">查看更多可配置信息</font></summary>


#### 相关API说明：

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------|  
| AdvanceInterstitial(Activity activity,String adspotId) | 广告初始化方法，adspotId为聚合广告位id同时也是Mercury 渠道的广告位id | 必须
|setAdListener(AdvanceInterstitialListener listener) | 设置各个事件的回调监听器，具体回调含义参考下方AdvanceInterstitialListener 说明| 可选
|loadStrategy()| 加载广告策略，根据返回的渠道顺序进行请求并展示广告。| 必须
|enableStrategyCache(boolean enableCache) | 是否开启策略缓存。注意这里缓存的是SDK的调度策略，而非缓存的广告信息。不设置默认关闭  <br/>后台广告位 |  可选，具体参考**1.6 最佳实践说明**
|setGdtMediaListener(UnifiedInterstitialMediaListener listener) | 广点通渠道特有设置，设置广点通的视频广告的播放回调。| 可选
|setCsjExpressViewAcceptedSize(float expressViewWidth, float expressViewHeight) |穿山甲渠道特有设置，期望模板广告view的size,单位dp。高度为0代表自适应，不设置默认宽高为300dp | 可选

</details>

* 事件回调 **AdvanceInterstitialListener**

| 方法名| 	方法介绍|  
|:------------- |:---------------|  
|onAdReady()	|成功获取广告信息回调，广告准备就绪
|onAdShow()	|广告成功展示回调 
|onAdFailed(AdvanceError advanceError) 	|广告加载失败回调
|onAdClicked()|	广告被点击回调
|onAdClose()|	用户关闭广告回调
|onSdkSelected(String sdkID) | 当前选中的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID



### 6.4原生模板(AdvanceNativeExpress)


集成最佳实践：

- 适用场景：适用于有内容输出的 APP，比如新闻资讯类、视频类、音频类、社区类等，通常在内容流中或内容详情页中植入。
- 常见尺寸：1）16:9，其中 640x360 尺寸用的最多，其次为 1280x720；2）2:1，640x320 尺寸用的最多。
- 一些建议：广告（排版格式、图片尺寸、内容调性等）与 APP 整体协调统一；
在内容流中植入广告，需对广告展现位置、展现频次等反复测试，避免过度干扰的同时，确保高可见性和效果性。
- 建议广告承载布局高度自适应，如要设置固定高度须知：穿山甲模板有最低高度限制，已知为最低125dp，Mercury最低80dp，广点通最低约100dp。
- 支持提前加载广告（注意控制时机，不可过早提前），但要注意，一次展示需对应一个广告实例，切忌复用广告实例。
- RecyclerView中使用的话请参考示例工程中的NativeExpressRecyclerViewActivity，建议在列表中每5-10个条目展示一条广告，且每次只请求一条广告，如果一定要请求多条请注意穿山甲支持的条数上限为3条。
- 需要注意如果广点通广告位使用的是否为**模板2.0**，模板2.0需要进行特殊的处理逻辑，且1.0和模板2.0互相不兼容，**默认使用模板2.0**来进行广告加载和展示。

请求广告核心方法，详细请参考demo中代码：


```java
//初始化广告
advanceNativeExpress = new AdvanceNativeExpress(this, "聚合模板信息流广告位id");
//推荐：核心事件监听回调
advanceNativeExpress.setAdListener(this);
//必须：请求策略并请求广告
advanceNativeExpress.loadStrategy();
```

展示广告

```java
 @Override
    public void onAdLoaded(List<AdvanceNativeExpressAdItem> list) {
        DemoUtil.logAndToast(this, "广告加载成功");

        if (null == list || list.isEmpty()) {
            Log.d("DEMO", "NO AD RESULT");
        } else {
            advanceNativeExpressAdItem = list.get(0);

            //穿山甲需要设置dislike逻辑，要在选中回调里移除广告
            if (AdvanceConfig.SDK_ID_CSJ.equals(advanceNativeExpressAdItem.getSdkId())) {
                CsjNativeExpressAdItem csjNativeExpressAdItem = (CsjNativeExpressAdItem) advanceNativeExpressAdItem;
                csjNativeExpressAdItem.setDislikeCallback(NativeExpressActivity.this, new TTAdDislike.DislikeInteractionCallback() {
                    @Override
                    public void onSelected(int i, String s) {
                        if (container != null)
                            container.removeAllViews();
                    }

                    @Override
                    public void onCancel() {

                    }

                    @Override
                    public void onRefuse() {

                    }
                });
            }

            //从实际执行结果中获取是否是广点通模板2.0类型广告
            isGdtExpress2 = AdvanceConfig.SDK_ID_GDT.equals(advanceNativeExpressAdItem.getSdkId()) && advanceNativeExpress.isGdtExpress2();

            //广点通模板2.0不可以在这里可以直接添加视图，否则无法展示，应该在onAdRenderSuccess中添加视图
            if (!isGdtExpress2) {
                container.removeAllViews();
                container.setVisibility(View.VISIBLE);
                container.addView(advanceNativeExpressAdItem.getExpressAdView());
            }
            //render以后才会进行广告渲染， 广告可见才会产生曝光，否则将无法产生收益。
            advanceNativeExpressAdItem.render();
        }
    }

    @Override
    public void onAdRenderSuccess(View view) {
        DemoUtil.logAndToast(this, "广告渲染成功");

        //广点通模板2.0 需要在RenderSuccess以后再加载视图
        if (advanceNativeExpressAdItem != null && advanceNativeExpressAdItem.getSdkId().equals(AdvanceConfig.SDK_ID_GDT) && isGdtExpress2) {
            container.removeAllViews();
            container.setVisibility(View.VISIBLE);
            //广告可见才会产生曝光，否则将无法产生收益。
            container.addView(advanceNativeExpressAdItem.getExpressAdView());
        }
    }
```


<details>
  <summary><font color="#0000ff">查看更多可配置信息</font></summary>


#### 相关API说明：

请求策略、加载广告相关API（AdvanceNativeExpress）

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------|  
| AdvanceNativeExpress(Activity activity,String adspotId) | 广告初始化方法，adspotId为聚合广告位id同时也是Mercury 渠道的广告位id | 必须
|setAdListener(AdvanceNativeExpressListener listener) | 设置各个事件的回调监听器，具体回调含义参考下方AdvanceNativeExpressListener 说明| 可选
|loadStrategy()| 加载广告策略，根据返回的渠道顺序进行请求并展示广告。| 必须
|enableStrategyCache(boolean enableCache) | 是否开启策略缓存。注意这里缓存的是SDK的调度策略，而非缓存的广告信息。不设置默认关闭  <br/>后台广告位 |  可选，具体参考**1.6 最佳实践说明**
|setExpressViewAcceptedSize(int width, int height)   | 设置期望的模板广告view的size,单位dp，同时适用于穿山甲、广点通、Mercury。不设置默认宽600dp 高0dp，**高度为0,代表自适应高度** | 可选
|setCsjImageAcceptedSize(int width, int height)  |穿山甲渠道特有设置，设置图片偏好尺寸，单位px，不设置默认宽640px  高320px | 可选
|setGdtFullWidth(boolean isFullWidth) | 广点通、Mercury 渠道特有设置，设置是否宽度占满，默认true | 可选
|setGdtAutoHeight(boolean isAutoHeight) | 广点通、Mercury 渠道特有设置，设置是否高度自适应，默认true | 可选
|setGdtMaxVideoDuration(int gdtMaxVideoDuration) | 广点通渠道特有设置，设置返回视频广告的最大视频时长（闭区间，可单独设置），单位:秒，合法输入为：5<=maxVideoDuration<=60. 此设置会影响广告填充，请谨慎设置，不设置默认60 | 可选

信息流子View相关API（AdvanceNativeExpressAdItem）

| 方法名| 	方法介绍
|:------------- |:---------------
|String getSdkId()   | 获取当前加载的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID
| destroy() | 销毁当前展示的信息流子View以及资源占用回收
|View getExpressAdView() | 获取当前信息流的广告视图View 
|render() | 渲染视图


</details> 

* 事件回调 **AdvanceNativeExpressListener**

| 方法名| 	方法介绍|  
|:------------- |:---------------|  
|onAdLoaded(List<AdvanceNativeExpressAdItem> list) |成功获取广告信息回调，广告准备就绪
|onAdFailed(AdvanceError advanceError)  | 获取广告信息失败回调
|onAdShow(View view) |  广告素材展示成功回调，view是当前展示成功的视图
|onAdRenderSuccess(View view)	|广告渲染成功回调，不一定曝光了 
|onAdRenderFailed(View view) |广告渲染失败回调
|onAdClicked(View view)|	广告被点击回调
|onAdClose(View view)|	用户关闭广告回调
|onSdkSelected(String sdkID) | 当前选中的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID



### 6.5激励视频(RewardVideo)

集成最佳实践：

- 适用场景：激励视频广告在游戏 APP 使用较多，比如通关失败后通过观看激励视频广告，用户可获取复活机会。此外，一些非游戏类 APP，也可通过植入 5-15 秒（甚至更长）的激励视频广告，让用户通过主动观看来享受到一些福利奖励、付费功能/权限等——比如网盘类 APP 通过观看激励视频广告来获取空间；视频、音频、音乐类 APP 通过观看激励视频广告来获取视频/音频/音乐免费观看或收听特权；图片类 APP 通过观看激励视频广告来获取图片下载特权；阅读类 APP 通过观看激励视频广告来获取书籍/漫画阅读特权等。
- 常见尺寸：激励视频广告常见为竖屏，比例 9:16，尺寸 720x1280；也有些 APP 采用横版样式，比例 16:9，尺寸 1280x720。
- 一些建议：广告植入密度不要过于频繁，以免拉低媒体调性和用户好感度；
将广告植入在既能刺激用户主动观看，同时又兼顾不对用户正常使用体验产生影响的位置。
- 激励达成事件请在广告激励回调`onAdReward `中进行，穿山甲支持服务器回传激励达成事件，但其他平台均不支持。
- 支持提前加载广告（注意控制时机，不可过早提前），但要注意，一次展示需对应一个广告实例，切忌复用广告实例。
- 需要注意如果广点通广告位使用的是否为**模板类型**，普通类型和模板类型互相不兼容，**默认使用模板类型**进行请求和加载广告。


加载广告核心方法，详细请参考demo中代码：


```java
//初始化广告
advanceRewardVideo = new AdvanceRewardVideo(this,"聚合激励视频广告位id");
//如果穿山甲版本号大于3.2.5.1，模板广告需要设置期望个性化模板广告的大小,单位dp,激励视频场景，只要设置的值大于0即可
advanceRewardVideo.setCsjExpressSize(500,500);
//设置通用事件监听器
advanceRewardVideo.setAdListener(this);
//必须：请求策略并请求广告
advanceNativeExpress.loadStrategy();
```

展示广告，以下代码表示收到广告立即展示。也可以选择提前加载好再展示，但要注意激励视频有失效时间，且一次load 对应一次show。


```java
//广告加载成功回调
@Override
public void onAdLoaded(AdvanceRewardVideoItem advanceRewardVideoItem) {
    isReady = true;
    Log.d("DEMO", "LOADED");
    this.advanceRewardVideoItem = advanceRewardVideoItem;
    Toast.makeText(this, "广告加载成功", Toast.LENGTH_SHORT).show();
    //展示广告
    advanceRewardVideoItem.showAd();
}
```


<details>
  <summary><font color="#0000ff">查看更多可配置信息</font></summary>

#### 相关API说明：

请求策略、加载广告相关API（AdvanceRewardVideo）

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------|  
| AdvanceRewardVideo(Activity activity,String adspotId) | 广告初始化方法，adspotId为聚合广告位id同时也是Mercury 渠道的广告位id | 必须
|setAdListener(AdvanceRewardVideoListener listener) | 设置各个事件的回调监听器，具体回调含义参考下方AdvanceRewardVideoListener 说明| 可选
|loadStrategy()| 加载广告策略，根据返回的渠道顺序进行请求并展示广告。| 必须
|enableStrategyCache(boolean enableCache) | 是否开启策略缓存。注意这里缓存的是SDK的调度策略，而非缓存的广告信息。不设置默认关闭  <br/>后台广告位 |  可选，具体参考**1.6 最佳实践说明**
|setCsjImageAcceptedSize(int width, int height) | 穿山甲渠道特有设置，设置穿山甲广告图片偏好尺寸，单位px，不设置默认宽1080px，高1920px | 可选
|setCsjRewardName(String rewardName) |  穿山甲渠道特有设置，设置奖励的名称，不设置默认空字符串 | 可选
|setCsjRewardAmount(int rewardAmount) |  穿山甲渠道特有设置，设置奖励的数量，不设置默认1 | 可选
|setCsjUserId(String userId) | 穿山甲渠道特有设置，标识应用侧唯一用户；若非服务器回调模式或不需sdk透传可设置为空字符串，不设置默认空字符串  | 可选
|setOrientation(int orientation) | 穿山甲渠道特有设置，设置期望视频播放的方向，为TTAdConstant.HORIZONTAL或TTAdConstant.VERTICAL（默认值）  | 可选
|setCsjMediaExtra(String mediaExtra) | 穿山甲渠道特有设置，用户透传的信息，可不传，默认空字符串  | 可选
|setCsjExpressSize(int width, int height) | 模板广告需要设置期望个性化模板广告的大小，单位dp，只要设置的值大于0即可  | 可选，如果穿山甲版本号大于3.2.5.1为必须

</details>


* 事件回调 **AdvanceRewardVideoListener**

| 方法名| 	方法介绍|  
|:------------- |:---------------|  
|onAdLoaded(AdvanceRewardVideoItem advanceRewardVideoItem) |成功获取广告信息回调，广告准备就绪
|onAdFailed(AdvanceError advanceError)  | 获取广告信息失败回调
|onAdShow() |  激励视频页面展示成功回调
|onVideoCached()	|视频缓冲成功回调
|onVideoComplete() | 视频播放完成回调
|onAdClicked()|	广告被点击回调
|onAdClose()|	用户关闭广告回调
| onAdReward()|	激励发放回调
|onSdkSelected(String sdkID) | 当前选中的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID


* 基础激励视频实现类 **AdvanceRewardVideoItem**

|方法名| 	方法介绍|  
|:------------- |:---------------|  
|String getSdkId() | 获取当前加载的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID
|showAd() | 展示当前激励视频广告

### 6.6 全屏视频(FullScreenVideo)

集成最佳实践：

- 使用场景基本类似激励视频，广告展示样式也和激励视频基本一致，区别是对于用户来说强制性更低，用户可以提前“跳过”广告。
- 支持提前加载广告（注意控制时机，不可过早提前），但要注意，一次展示需对应一个广告实例，切忌复用广告实例。
 

加载广告核心方法，详细请参考demo中代码：


```java
//初始化广告
advanceFullScreenVideo = new AdvanceFullScreenVideo(this, "聚合全屏视频广告位id");
//如果穿山甲版本号大于3.2.5.1，模板广告需要设置期望个性化模板广告的大小,单位dp,全屏视频场景，只要设置的值大于0即可
advanceFullScreenVideo.setCsjExpressSize(500,500);
//推荐：核心事件监听回调
advanceFullScreenVideo.setAdListener(this);
//必须：请求策略并请求广告
advanceNativeExpress.loadStrategy();
```

展示广告

```java
//广告加载成功回调
@Override
public void onAdLoaded(AdvanceFullScreenItem advanceFullScreenItem) {
    Log.d(TAG, "onAdLoaded");
    //展示广告
    advanceNativeExpress.showAd();
}
```


<details>
  <summary><font color="#0000ff">查看更多可配置信息</font></summary>

请求策略、加载广告相关API（AdvanceFullScreenVideo）

| 方法名| 	方法介绍|  是否必须
|:------------- |:---------------|  :---------------|  
| AdvanceRewardVideo(Activity activity,String adspotId) | 广告初始化方法，adspotId为聚合广告位id同时也是Mercury 渠道的广告位id | 必须
|setAdListener(AdvanceFullScreenVideoListener listener) | 设置各个事件的回调监听器，具体回调含义参考下方AdvanceFullScreenVideoListener 说明| 可选
|loadStrategy()| 加载广告策略，根据返回的渠道顺序进行请求并展示广告。| 必须
|enableStrategyCache(boolean enableCache) | 是否开启策略缓存。注意这里缓存的是SDK的调度策略，而非缓存的广告信息。不设置默认关闭  <br/>后台广告位 |  可选，具体参考**1.6 最佳实践说明**
|setGdtMediaListener(UnifiedInterstitialMediaListener mediaListener) | 广点通渠道特有设置， 设置广点通媒体播放状态监听| 可选
|setGdtVideoOption(VideoOption videoOption)| 广点通渠道特有设置，设置广点通视频播放策略| 可选
|setCsjExpressSize(int width, int height) | 模板广告需要设置期望个性化模板广告的大小，单位dp，只要设置的值大于0即可  | 可选，如果穿山甲版本号大于3.2.5.1为必须


</details>

* 事件回调 **AdvanceFullScreenVideoListener**

| 方法名| 	方法介绍|  
|:------------- |:---------------|  
|onAdLoaded(AdvanceFullScreenItem advanceFullScreenItem) |成功获取广告信息回调，广告准备就绪
|onAdFailed(AdvanceError advanceError)  | 获取广告信息失败回调
|onAdShow() |  视频页面展示成功回调
|onVideoCached()	|视频缓冲成功回调
|onVideoSkipped()	|视频跳过回调
|onVideoComplete() | 视频播放完成回调
|onAdClicked()|	广告被点击回调
|onAdClose()|	用户关闭广告回调
|onSdkSelected(String sdkID) | 当前选中的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID

* 基础全屏视频实现类 **AdvanceFullScreenItem**

|方法名| 	方法介绍|  
|:------------- |:---------------|  
|String getSdkId() | 获取当前加载的SDK渠道，sdkID对应 **1.4 SDK渠道平台信息**中的SDK ID
|showAd() | 展示当前激励视频广告





## 7.自定义广告

非自定义的各个广告位是由我们Advance SDK来默认实现了通用的需求，且广告位和SDK渠道位比较固定，比较适合希望快速实现的客户；自定义广告位是广告的具体实现和展示由客户端来决定，这样可以满足客户端的多样性需求，而Advance SDK主要来负责策略（使用哪个SDK加载广告的策略）的下发和数据统计上报，客户端需要适配开发，比较适合希望实现自渲染广告等多样性格式广告或者需要除 上面1.3表格中支持的渠道以外的需求。

目前自定义广告可以实现SDK渠道和广告位的自定义，但暂未开放给客户自己添加的权限，如果需要新增渠道或者广告位烦请联系我们。

 
### 7.1 原生自渲染广告自定义示例

#### 自定义原生自渲染广告初始化

和自定义开屏示例一样， 初始化`AdvanceCustomizeAd`后，策略加载成功回调中初始化各渠道adapter，并请求广告。

原生自渲染activity示例：

```
public class NativeCustomizeActivity extends Activity {

    AdvanceCustomizeAd nativeCustomizeAd;
    FrameLayout fl;
    String Tag = NativeCustomizeActivity.class.getSimpleName();

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_ad_container);
        fl = findViewById(R.id.fl_ad);

        //创建自己的自渲染广告位，第二个参数为后台申请的广告位id
        nativeCustomizeAd = new AdvanceCustomizeAd(this, "");
        //必须：设置广告载体
        nativeCustomizeAd.setSupplierListener(new AdvanceCustomizeSupplierListener() {
            @Override
            public void onSupplierFailed(AdvanceError advanceError)  {
                //一般是策略无填充，或者所有策略均加载失败时回调
                fl.removeAllViews();
            }

            @Override
            public void onSupplierSelected(SdkSupplier selectedSupplier) {
                //策略选择回调，可根据不同的渠道ID来加载各渠道广告
                switch (selectedSupplier.id) {
                    case AdvanceConfig.SDK_ID_CSJ:
                        new MyCsjNCAdapter(NativeCustomizeActivity.this, nativeCustomizeAd, selectedSupplier, fl).loadAd();
                        break;
                    case AdvanceConfig.SDK_ID_GDT:
                        new MyGdtNCAdapter(NativeCustomizeActivity.this, nativeCustomizeAd, selectedSupplier, fl).loadAd();
                        break;
                    case AdvanceConfig.SDK_ID_MERCURY:
                        new MyMercuryNCAdapter(NativeCustomizeActivity.this, nativeCustomizeAd, selectedSupplier, fl).loadAd();
                        break;
                    default:
                        //不需要支持的渠道，建议选择重新调度策略
                        nativeCustomizeAd.selectSdkSupplier();
                }
            }
        });
//        发起策略请求
        nativeCustomizeAd.loadStrategy();
    }


}
```

#### 设置各个渠道的adapter

渠道adapter来负责各个渠道的广告加载流程，这里以穿山甲渠道`MyCsjNCAdapter`的实现为例，其他渠道请下载demo工程参考具体的实现。

<font size = "2">**注意**：一定要按照示例调用customizeAd 的对应事件方法

```

public class MyCsjNCAdapter implements TTAdNative.FeedAdListener {

    private Activity activity;
    private SdkSupplier sdkSupplier;
    private AdvanceCustomizeAd customizeAd;
    private ViewGroup adContainer;

    public MyCsjNCAdapter(Activity activity, AdvanceCustomizeAd customizeAd, SdkSupplier sdkSupplier, ViewGroup adContainer) {
        this.activity = activity;
        this.customizeAd = customizeAd;
        this.sdkSupplier = sdkSupplier;
        this.adContainer = adContainer;
    }

    public void loadAd() {
        //初始化advance默认的穿山甲配置，也可以自己选择初始化方式
        AdvanceUtil.initCsj(activity, sdkSupplier.mediaid);

        TTAdManager ttAdManager = TTAdSdk.getAdManager();
        if (AdvanceConfig.getInstance().isNeedPermissionCheck()) {
            ttAdManager.requestPermissionIfNecessary(activity);
        }
        TTAdNative ttAdNative = ttAdManager.createAdNative(activity);
        //step3:(可选，强烈建议在合适的时机调用):申请部分权限，如read_phone_state,防止获取不了imei时候，下载类广告没有填充的问题。
        ttAdManager.requestPermissionIfNecessary(activity);
        //step4:创建feed广告请求类型参数AdSlot,具体参数含义参考文档
        AdSlot adSlot = new AdSlot.Builder()
                // 必选参数 设置您的CodeId
                .setCodeId(sdkSupplier.adspotid)
                // 必选参数 设置广告图片的最大尺寸及期望的图片宽高比，单位Px
                .setImageAcceptedSize(640, 320)
                // 可选参数 设置是否支持deeplink
                .setSupportDeepLink(true)
                .setAdCount(sdkSupplier.adCount) //请求广告数量为1到3条
                .build();
        ttAdNative.loadFeedAd(adSlot, this);
    }

    @Override
    public void onError(int code, String message) {
        //这里一定要调用customizeAd 的事件方法
        if (customizeAd != null)
            customizeAd.adapterDidFailed(AdvanceError.parseErr(code, message));
    }


    @Override
    public void onFeedAdLoad(List<TTFeedAd> ads) {
        if (ads == null || ads.isEmpty()) {
            //这里一定要调用customizeAd 的事件方法
            if (customizeAd != null)
                customizeAd.adapterDidFailed(AdvanceError.parseErr(ERROR_DATA_NULL));
        } else {
            //这里一定要调用customizeAd 的事件方法
            if (customizeAd != null)
                customizeAd.adapterDidSucceed();

            CsjAdData advanceNativeAdData = new CsjAdData(ads.get(0));
            advanceNativeAdData.showAd();
        }
    }

    class CsjAdData {
        private View adView;
        TTFeedAd ad;

        ImageView mIcon;
        ImageView mDislike;
        Button mCreativeButton;
        TextView mTitle;
        TextView mDescription;
        TextView mSource;

        ImageView mGroupImage1;
        ImageView mGroupImage2;
        ImageView mGroupImage3;
        LinearLayout mGroupContainer;

        private FrameLayout videoLayout;
        private ImageView mImagePoster;
        private ImageView mSmallImagePoster;
        private LinearLayout nativeContainer;
        private Map<CsjAdData, TTAppDownloadListener> mTTAppDownloadListenerMap = new WeakHashMap<>();
        String TAG = "CsjAdData";

        public CsjAdData(TTFeedAd adData) {
            this.ad = adData;

            try {
                //小图布局不太一样
                if (ad.getImageMode() == TTAdConstant.IMAGE_MODE_SMALL_IMG) {
                    adView = LayoutInflater.from(activity).inflate(R.layout.csj_nc_layout_small, null, false);
                } else {
                    adView = LayoutInflater.from(activity).inflate(R.layout.csj_nc_layout, null, false);
                }
                initViews();
            } catch (Exception e) {
                e.printStackTrace();
                //这里一定要调用customizeAd 的事件方法
                if (customizeAd != null)
                    customizeAd.adapterDidFailed(AdvanceError.parseErr(ERROR_EXCEPTION_LOAD));
            }
        }

        private void initViews() {
            mIcon = adView.findViewById(R.id.iv_nc_icon);
            mDislike = adView.findViewById(R.id.iv_nc_dislike);
            mCreativeButton = adView.findViewById(R.id.btn_nc_creative);
            mTitle = adView.findViewById(R.id.tv_nc_ad_title);
            mDescription = adView.findViewById(R.id.tv_nc_ad_desc);
            mSource = adView.findViewById(R.id.tv_nc_ad_source);


            nativeContainer = adView.findViewById(R.id.native_ad_container);

            if (ad.getImageMode() == TTAdConstant.IMAGE_MODE_SMALL_IMG) {
                mSmallImagePoster = adView.findViewById(R.id.iv_nc_small_image);
            } else {
                mGroupContainer = adView.findViewById(R.id.native_3img);
                mGroupImage1 = adView.findViewById(R.id.img_1);
                mGroupImage2 = adView.findViewById(R.id.img_2);
                mGroupImage3 = adView.findViewById(R.id.img_3);

                videoLayout = adView.findViewById(R.id.iv_nc_video);
                mImagePoster = adView.findViewById(R.id.img_poster);
            }

        }

        public void showAd() {
            try {
                if (adContainer == null) {
                    Log.e(TAG, "广告位载体为空，请检查载体设置");
                    return;
                }
                adContainer.removeAllViews();
                //设置dislike弹窗，这里展示自定义的dialog
                bindDislikeCustom(ad);

                bindData(ad);
                adContainer.addView(adView);

            } catch (Exception e) {
                e.printStackTrace();
                //这里一定要调用customizeAd 的事件方法
                if (customizeAd != null)
                    customizeAd.adapterDidFailed(AdvanceError.parseErr(ERROR_EXCEPTION_SHOW));
            }
        }

        private void bindData(TTFeedAd ad) {
            //可以被点击的view, 也可以把adView放进来意味整个布局可被点击
            List<View> clickViewList = new ArrayList<>();
            clickViewList.add(adView);
            //触发创意广告的view（点击下载或拨打电话）
            List<View> creativeViewList = new ArrayList<>();
            creativeViewList.add(mCreativeButton);
            //如果需要点击图文区域也能进行下载或者拨打电话动作，请将图文区域的view传入
//            creativeViewList.add(convertView);
            //重要! 这个涉及到广告计费，必须正确调用。convertView必须使用ViewGroup。
            ad.registerViewForInteraction((ViewGroup) adView, clickViewList, creativeViewList, new TTNativeAd.AdInteractionListener() {
                @Override
                public void onAdClicked(View view, TTNativeAd ad) {
                    //这里一定要调用customizeAd 的事件方法
                    if (customizeAd != null)
                        customizeAd.adapterDidClicked();
                }

                @Override
                public void onAdCreativeClick(View view, TTNativeAd ad) {
                    //这里一定要调用customizeAd 的事件方法
                    if (customizeAd != null)
                        customizeAd.adapterDidClicked();
                }

                @Override
                public void onAdShow(TTNativeAd ad) {
                    //这里一定要调用customizeAd 的事件方法
                    if (customizeAd != null)
                        customizeAd.adapterDidShow();
                }
            });
            mTitle.setText(ad.getTitle()); //title为广告的简单信息提示
            mDescription.setText(ad.getDescription()); //description为广告的较长的说明
            mSource.setText(ad.getSource() == null ? "广告来源" : ad.getSource());
            TTImage icon = ad.getIcon();
            if (icon != null && icon.isValid()) {
                Glide.with(activity).load(icon.getImageUrl()).into(mIcon);
            }

            switch (ad.getImageMode()) {
                case TTAdConstant.IMAGE_MODE_SMALL_IMG:
                    if (ad.getImageList() != null && !ad.getImageList().isEmpty()) {
                        TTImage image = ad.getImageList().get(0);
                        if (image != null && image.isValid()) {
                            Glide.with(activity).load(image.getImageUrl()).into(mSmallImagePoster);
                        }
                    }

                    break;
                case TTAdConstant.IMAGE_MODE_LARGE_IMG:
                case TTAdConstant.IMAGE_MODE_VERTICAL_IMG:
                    if (ad.getImageList() != null && !ad.getImageList().isEmpty()) {
                        TTImage image = ad.getImageList().get(0);
                        if (image != null && image.isValid()) {
                            Glide.with(activity).load(image.getImageUrl()).into(mImagePoster);
                        }
                    }

                    mImagePoster.setVisibility(View.VISIBLE);
                    videoLayout.setVisibility(View.GONE);
                    mGroupContainer.setVisibility(View.GONE);
                    break;
                case TTAdConstant.IMAGE_MODE_VIDEO:

                    videoLayout.setVisibility(View.VISIBLE);
                    mGroupContainer.setVisibility(View.GONE);
                    mImagePoster.setVisibility(View.GONE);
                    //视频广告设置播放状态回调（可选）
                    ad.setVideoAdListener(new TTFeedAd.VideoAdListener() {
                        @Override
                        public void onVideoLoad(TTFeedAd ad) {

                        }

                        @Override
                        public void onVideoError(int errorCode, int extraCode) {

                        }

                        @Override
                        public void onVideoAdStartPlay(TTFeedAd ad) {

                        }

                        @Override
                        public void onVideoAdPaused(TTFeedAd ad) {

                        }

                        @Override
                        public void onVideoAdContinuePlay(TTFeedAd ad) {

                        }

                        @Override
                        public void onProgressUpdate(long current, long duration) {
                            Log.e("VideoAdListener", "===onProgressUpdate current:" + current + " duration:" + duration);
                        }

                        @Override
                        public void onVideoAdComplete(TTFeedAd ad) {
                            Log.e("VideoAdListener", "===onVideoAdComplete");
                        }
                    });
                    if (videoLayout != null) {
                        View video = ad.getAdView();
                        if (video != null) {
                            if (video.getParent() == null) {
                                videoLayout.removeAllViews();
                                videoLayout.addView(video);
                            }
                        }
                    }
                    break;
                case TTAdConstant.IMAGE_MODE_GROUP_IMG:
                    if (ad.getImageList() != null && ad.getImageList().size() >= 3) {
                        TTImage image1 = ad.getImageList().get(0);
                        TTImage image2 = ad.getImageList().get(1);
                        TTImage image3 = ad.getImageList().get(2);
                        if (image1 != null && image1.isValid()) {
                            Glide.with(activity).load(image1.getImageUrl()).into(mGroupImage1);
                        }
                        if (image2 != null && image2.isValid()) {
                            Glide.with(activity).load(image2.getImageUrl()).into(mGroupImage2);
                        }
                        if (image3 != null && image3.isValid()) {
                            Glide.with(activity).load(image3.getImageUrl()).into(mGroupImage3);
                        }

                        mGroupContainer.setVisibility(View.VISIBLE);
                        videoLayout.setVisibility(View.GONE);
                        mImagePoster.setVisibility(View.GONE);
                    }
                    break;
            }

            switch (ad.getInteractionType()) {
                case TTAdConstant.INTERACTION_TYPE_DOWNLOAD:
                    //如果初始化ttAdManager.createAdNative(getApplicationContext())没有传入activity 则需要在此传activity，否则影响使用Dislike逻辑
                    ad.setActivityForDownloadApp(activity);
                    mCreativeButton.setVisibility(View.VISIBLE);
                    bindDownloadListener(mCreativeButton, ad);
                    break;
                case TTAdConstant.INTERACTION_TYPE_DIAL:
                    mCreativeButton.setVisibility(View.VISIBLE);
                    mCreativeButton.setText("立即拨打");
                    break;
                case TTAdConstant.INTERACTION_TYPE_LANDING_PAGE:
                case TTAdConstant.INTERACTION_TYPE_BROWSER:
                    mCreativeButton.setVisibility(View.VISIBLE);
                    mCreativeButton.setText("查看详情");
                    break;
                default://                    交互类型异常
                    mCreativeButton.setVisibility(View.GONE);
            }


        }

        private void bindDislikeCustom(TTFeedAd ad) {
            List<FilterWord> words = ad.getFilterWords();
            if (words == null || words.isEmpty()) {
                return;
            }

            final DislikeDialog dislikeDialog = new DislikeDialog(activity, words);
            dislikeDialog.setOnDislikeItemClick(new DislikeDialog.OnDislikeItemClick() {
                @Override
                public void onItemClick(FilterWord filterWord) {
                    //布局清除
                    if (adContainer != null)
                        adContainer.removeAllViews();
                }
            });
            final TTAdDislike ttAdDislike = ad.getDislikeDialog(dislikeDialog);

            mDislike.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    //展示dislike可以自行调用dialog
                    dislikeDialog.show();

                    //也可以使用接口来展示
                    //ttAdDislike.showDislikeDialog();
                }
            });
        }

        private void bindDownloadListener(final Button adCreativeButton, TTFeedAd ad) {
            TTAppDownloadListener downloadListener = new TTAppDownloadListener() {
                @Override
                public void onIdle() {
                    if (!isValid()) {
                        return;
                    }
                    adCreativeButton.setText("开始下载");

                }

                @SuppressLint("SetTextI18n")
                @Override
                public void onDownloadActive(long totalBytes, long currBytes, String fileName, String appName) {
                    if (!isValid()) {
                        return;
                    }
                    if (totalBytes <= 0L) {
                        adCreativeButton.setText("0%");
                    } else {
                        adCreativeButton.setText((currBytes * 100 / totalBytes) + "%");
                    }

                }

                @SuppressLint("SetTextI18n")
                @Override
                public void onDownloadPaused(long totalBytes, long currBytes, String fileName, String appName) {
                    if (!isValid()) {
                        return;
                    }
                    if (totalBytes <= 0L) {
                        adCreativeButton.setText("0%");
                    } else {
                        adCreativeButton.setText((currBytes * 100 / totalBytes) + "%");
                    }

                }

                @Override
                public void onDownloadFailed(long totalBytes, long currBytes, String fileName, String appName) {
                    if (!isValid()) {
                        return;
                    }
                    adCreativeButton.setText("重新下载");

                }

                @Override
                public void onInstalled(String fileName, String appName) {
                    if (!isValid()) {
                        return;
                    }
                    adCreativeButton.setText("点击打开");

                }

                @Override
                public void onDownloadFinished(long totalBytes, String fileName, String appName) {
                    if (!isValid()) {
                        return;
                    }
                    adCreativeButton.setText("点击安装");

                }

                @SuppressWarnings("BooleanMethodIsAlwaysInverted")
                private boolean isValid() {
                    return mTTAppDownloadListenerMap.get(CsjAdData.this) == this;
                }
            };
            //一个ViewHolder对应一个downloadListener, isValid判断当前ViewHolder绑定的listener是不是自己
            ad.setDownloadListener(downloadListener); // 注册下载监听器
            mTTAppDownloadListenerMap.put(CsjAdData.this, downloadListener);
        }

    }
}

```

###  7.2 其他自定义广告

自定义开屏和自定义自渲染原理类似，具体代码请参考最新demo中的`CustomSplashActivity`类文件。

自定义激励视频和自定义自渲染原理类似，具体代码请参考最新demo中的`CustomRewardActivity`类文件。

自定义横幅广告和自定义自渲染原理类似，具体代码请参考最新demo中的`CustomBannerActivity`类文件。

自定义插屏广告和自定义自渲染原理类似，具体代码请参考最新demo中的`CustomInterstitialActivity`类文件。

自定义模板信息流广告自定义自渲染原理类似，具体代码请参考最新demo中的`CustomNativeExpressListActivity`类文件。

自定义全屏视频广告自定义自渲染原理类似，具体代码请参考最新demo中的`CustomFullScreenActivity`类文件。

 
### 7.3 自定义广告注意事项

* 1.确保广告各个展示周期（加载、展示、点击、失败）的事件上报正常，调用方法分别是 adapterDidSucceed()，adapterDidShow()， adapterDidClicked()，adapterDidFailed()。

* 2.在自定义渠道信息时，如果`selectedSupplier`返回了未实现的渠道id（即不可用渠道），需要调用`AdvanceCustomizeAd.selectSdkSupplier()`重启策略选择方法，寻找下一个可用的SDK渠道策略。
* 3.自定义广告当前仅支持串行加载，暂不支持串并行



## 8.异常处理

### 8.1 debug日志排查

如果集成完成，需要调试sdk请务必在**SDK初始化配置时打开debug模式**, 或者直接在需要debug的地方调用：

	AdvanceConfig.getInstance().setDebug(true)
	
然后在` Android Studio`  中的 ` Logcat` 下搜索 **advance** 关键字，即可查看SDK中所有的打印日志。

<font size=2>注： 部分手机需要在开发者选项打开日志打印开关，部分华为手机需要系统设置中开启日志打印，如果无法打印请先确认手机系统设置是否正常。</font>

	
### 8.2 Advance SDK错误码

* com.advance.model.AdvanceError 异常信息包装类

|错误码 	  | 错误详情 | 排查方向
|:------------- |:---------------|  :---------------|  
|9901| 数据为空 |广告返回的数据为空，一般为渠道广告无填充。
|9902 | 加载某个SDK渠道时发生异常| 查看logcat下日志输出，寻找具体原因
|9903 |展示某个SDK渠道时发生异常| 查看logcat下日志输出，寻找具体原因
|9904|渲染某个SDK渠道时发生异常| 查看logcat下日志输出，寻找具体原因
|9905|当前策略中无有效的SDK渠道，或渠道信息为空 | 检查聚合后台中对应广告位的渠道设置，有可能是配错渠道或者没有配置
|9906| 策略调度时发生异常 | 查看logcat下日志输出，及时反馈我们帮助排查
|9907|未获取到策略 |首先检查网络是否正常，若网络正常请检查聚合后台广告位状态是否正常，以及广告位配置是否正确，若全部配置正常，依然报此问题，请联系我们
|9908|某个SDK渠道启动异常| 查看logcat下日志输出，及时反馈我们帮助排查
|9909|穿山甲渠道SDK超时且不再加载优先级更低的渠道 | 加载超时，检查网络是否正常。仅开屏中会出现，代表开屏广告位中配置了setCsjTimeOutQuit(true)，低频可忽略
|9910 | 穿山甲渠道SDK加载超时 | 加载超时，检查网络是否正常
|9911 | 百度SDK加载失败 | 查看logcat下日志输出，寻找具体原因
|9912 | 快手SDK加载失败，广告位id类型转换异常 | 一般是广告位转换出错，检查后台配置的快手渠道下广告位id是否为纯数字，非纯数字会引起该异常。
|99_XXX | 某个SDK渠道返回的错误，其中XXX为该SDK渠道返回的具体错误码 | 翻阅各个平台下的错误码说明查找具体原因： <br/>穿山甲：[错误码说明，点击跳转](https://www.pangle.cn/union/media/union/download/detail?id=4&docId=5de8d9b925b16b00113af0ed&osType=android)<br/>广点通：[错误码说明，点击跳转](https://developers.adnet.qq.com/doc/android/union/union_debug#sdk%20%E9%94%99%E8%AF%AF%E7%A0%81)<br/>百度：[接入文档，点击跳转；错误码详见17.2](https://union.baidu.com/miniappblog/2020/06/16/AndroidSDK/) <br/>快手：无在线文档，[点击下载离线文档，查看详细错误信息](https://static.yximgs.com/udata/pkg/KS-Android-KSAdSDk/kssdk-ad-3.3.5.3-publishRelease-6d3b66a-167.zip)

### 8.3 其他异常处理

Q: 项目构建时出现 “unexpected element < queries> found in < manifest>”异常?

A: queries是Android11新引入的manifest基础成分，低版本的gradle无法识别，[点此查看详细说明](https://stackoverflow.com/questions/62969917/how-do-i-fix-unexpected-element-queries-found-in-manifest)。Google发布了以下插件包更新来支持此特性，建议升级Android Gradle Plugin 到以下版本：
 
- 3.3.3
- 3.4.3
- 3.5.4
- 3.6.4
- 4.0.1

---

Q: 请求不到广告怎么办？

A: 首先检查广告位的ID配置是否正确，是否按照文档要求请求广告，然后根据SDK返回的异常code和msg，翻阅上面 **8.2 SDK错误码**来分析错误原因。

---


## 9 测试验收

一般广告可以正常展示、点击、跳转即代表集成成功。

开发对接期间广告位状态为测试状态，发版放量前请告知我们，以便安排正式广告填充。
